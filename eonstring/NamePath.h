#pragma once
#include "Name.h"
#include <eoninlinetest/InlineTest.h>


///////////////////////////////////////////////////////////////////////////////
//
// The 'eon' namespace encloses all public functionality
//
namespace eon
{
	///////////////////////////////////////////////////////////////////////////
	// Eon Name Path Class - eon::namepath.
	//
	// A name path is a list of names that can be used to identify a
	// resource in a hierarchial structure by defining a path through the
	// structure to a target.
	//
	// In string format, the names (elements) are separated using forward slash.
	//
	class namepath
	{
		///////////////////////////////////////////////////////////////////////
		//
		// Construction
		//
	public:

		namepath() = default;
		namepath( const namepath& ) = default;
		namepath( namepath&& ) noexcept = default;

		inline namepath( const string& ref ) { *this = ref; }
		inline namepath( std::initializer_list<name_t> value ) { for( auto name : value ) Value.push_back( name ); }
		inline namepath( std::vector<name_t>::const_iterator beg, std::vector<name_t>::const_iterator end ) {
			Value.assign( beg, end ); }

		virtual ~namepath() = default;




		///////////////////////////////////////////////////////////////////////
		//
		// Read-only Methods
		//
	public:

		// Check if reference is empty.
		inline bool empty() const noexcept { return Value.empty(); }

		// Check if reference contains something.
		inline explicit operator bool() const noexcept { return !Value.empty(); }

		// Get number of elements (names) in reference.
		inline size_t numElms() const noexcept { return Value.size(); }

		// Get an element in the reference.
		// Returns [eon::no_name] if position is beyond the last element.
		inline name_t at( size_t pos ) const noexcept { return pos < Value.size() ? Value[ pos ] : no_name; }

		// Get the last element.
		// Returns [eon::no_name] if empty.
		inline name_t last() const noexcept { return !Value.empty() ? Value[ Value.size() - 1 ] : no_name; }


		// Get reference with first element removed.
		inline namepath chopFirst() const noexcept {
			return *this ? namepath( Value.begin() + 1, Value.end() ) : namepath(); }

		// Get reference with last element removed.
		inline namepath chopLast() const noexcept {
			return *this ? namepath( Value.begin(), Value.end() - 1 ) : namepath(); }


		// Get reference as a string.
		inline string str() const noexcept
		{
			string s{ "@" };
			for( auto name : Value )
			{
				if( s.numChars() > 2 )
					s += "/";
				s += eon::str( name );
			}
			return s;
		}


		// Get hash value.
		inline size_t hash() const noexcept
		{
			static std::hash<uint32_t> hasher;
			size_t val{ 0 };
			for( auto name : Value )
				val = val * 37 + hasher( name.value() );
			return val;
		}


		// Comparison.
		int compare( const namepath& other ) const noexcept;

		inline friend bool operator<( const namepath& a, const namepath& b ) noexcept { return a.compare( b ) < 0; }
		inline friend bool operator<=( const namepath& a, const namepath& b ) noexcept { return a.compare( b ) <= 0; }
		inline friend bool operator>( const namepath& a, const namepath& b ) noexcept { return a.compare( b ) > 0; }
		inline friend bool operator>=( const namepath& a, const namepath& b ) noexcept { return a.compare( b ) >= 0; }
		inline friend bool operator==( const namepath& a, const namepath& b ) noexcept { return a.compare( b ) == 0; }
		inline friend bool operator!=( const namepath& a, const namepath& b ) noexcept { return a.compare( b ) != 0; }




		///////////////////////////////////////////////////////////////////////
		//
		// Write Methods
		//
	public:

		// Set the reference.
		namepath& operator=( const namepath& ) = default;

		// Take ownership of another reference's value.
		namepath& operator=( namepath&& ) noexcept = default;

		// Parse from string.
		// NOTE: Will ignore illegal name characters and only use legal ones. Empty elements will also be ignored!
		namepath& operator=( const string& ref );

		inline namepath& operator=( std::initializer_list<name_t> names )
		{
			for( auto name : names )
				Value.push_back( name );
			return *this;
		}

		// Clear the reference.
		inline void clear() noexcept { Value.clear(); }

		// Add a name to the end of the reference.
		// Will not add [eon::no_name], but also not report it!
		inline namepath& add( name_t name ) { if( name != no_name ) { Value.push_back( name ); } return *this; }




		///////////////////////////////////////////////////////////////////////
		//
		// Attributes
		//
	private:

		std::vector<name_t> Value;
	};
}




namespace std
{
	// Allow implicit use of [eon::namepath] as key/value when used in
	// containers such as 'std::unordered_map' and 'std::unordered_set'.
	template<>
	struct hash<::eon::namepath>
	{
		inline size_t operator()( const ::eon::namepath& rhs ) const { return static_cast<size_t>( rhs.hash() ); }
	};
	template<>
	struct equal_to<::eon::namepath>
	{
		inline bool operator()( const ::eon::namepath& a, const ::eon::namepath& b ) const { return a == b; }
	};
};
